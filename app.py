#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
App.py — Scenario & Analog-Based Trading Framework
==================================================

Purpose
-------
Given a user-defined macro scenario (e.g., shocks to USD/DXY, rates, volatility),
this app finds historically similar ("analog") periods and compares their forward
returns to a simple predictive model, producing a blended view and a suggested
portfolio tilt across metals, FX, and BTC.

Assets Covered (default tickers)
--------------------------------
- Gold spot proxy: "XAUUSD=X"    (Yahoo Finance FX ticker, gold vs USD)
- Silver futures:  "SI=F"
- Bitcoin:         "BTC-USD"
- EUR/USD:         "EURUSD=X"
- USD/JPY:         "JPY=X" or "USDJPY=X" (we use "JPY=X" = USD/JPY on Yahoo)
- DXY (USD index): "DX-Y.NYB"    (exogenous factor, not directly traded here)
- US 10Y yield:    "^TNX"        (exogenous factor; 10y yield in percentage *10)
- VIX index:       "^VIX"        (exogenous factor)

You can modify the ASSET_TICKERS and FACTOR_TICKERS sets below.

Scenario Inputs
---------------
- Shocks to exogenous factors over the next H trading days:
  * dxy_shock:    expected % change over horizon (e.g., -0.05 = -5%)
  * tnx_shock:    expected change in 10y yield in basis points (e.g., -50)
  * vix_shock:    expected absolute change in VIX level (e.g., +10)

Method
------
1) Data Pipeline
   - Fetch historical prices from Yahoo Finance.
   - Construct feature matrix from factor changes over a lookback window (L days).

2) Analog Search
   - For each historical day, compute factor deltas over H days, compare to the
     user scenario via Euclidean distance in standardized space.
   - Select k nearest analogs.
   - Compute forward returns of target assets for those analog dates.

3) Predictive Model
   - Train Ridge regression (multi-target) mapping factor deltas to forward returns.

4) Blend & Portfolio Construction
   - Blend analog mean and model prediction (alpha).
   - Estimate covariance from analog windows.
   - Solve a long-only mean-variance portfolio with simplex projection.

5) Reporting
   - Print scenario, analog list, forward-return distributions, blended view,
     and suggested weights. Save a CSV report and optional PNGs.

Usage
-----
$ python App.py --start 2010-01-01 --end 2025-10-30 \
    --horizon 20 --lookback 20 --kneighbors 50 \
    --dxy_shock -0.05 --tnx_shock -50 --vix_shock 8 \
    --alpha 0.5 --plot

Notes
-----
- Requires: pandas, numpy, scikit-learn, yfinance, matplotlib (if --plot).
- ^TNX note: Yahoo reports it in "tenths of a percent". We convert to percentage points.
- DXY ticker "DX-Y.NYB" sometimes has gaps; you may substitute "DXY" from other sources
  or use "UUP" ETF (with caveats).

Author
------
This file was generated by ChatGPT as a template and should be reviewed before live trading.
"""
from __future__ import annotations

import argparse
import json
from dataclasses import dataclass, asdict
from typing import Dict, List, Tuple, Optional

import numpy as np
import pandas as pd

try:
    import yfinance as yf
except Exception as e:
    raise SystemExit("yfinance is required. Install with `pip install yfinance`.") from e

# Optional plotting
try:
    import matplotlib.pyplot as plt
    HAS_MPL = True
except Exception:
    HAS_MPL = False


# ----------------------------- Configuration ---------------------------------

ASSET_TICKERS: Dict[str, str] = {
    # tradables / positions
    "Gold": "XAUUSD=X",     # gold spot vs USD on Yahoo
    "Silver": "SI=F",
    "BTC": "BTC-USD",
    "EURUSD": "EURUSD=X",
    "USDJPY": "JPY=X",      # Yahoo "JPY=X" is USD/JPY (FX); check your environment
}

FACTOR_TICKERS: Dict[str, str] = {
    # exogenous drivers
    "DXY": "DX-Y.NYB",   # US Dollar index (can be illiquid; consider "UUP" ETF as proxy)
    "TNX": "^TNX",       # UST 10y yield (tenths of a percent)
    "VIX": "^VIX",
}

DEFAULTS = dict(
    start="2010-01-01",
    end=None,
    horizon=20,
    lookback=20,
    kneighbors=50,
    alpha=0.5,          # blend weight between analog mean and model prediction
    ridge_l2=1.0,
    risk_aversion=10.0, # higher -> more risk-averse (mv optimization)
    seed=42,
)


# ----------------------------- Utilities -------------------------------------

def pct_change_over_horizon(series: pd.Series, horizon: int) -> pd.Series:
    """Compute forward % change over H days: (P[t+H]/P[t]) - 1, aligned to t."""
    return series.shift(-horizon) / series - 1.0


def level_change_over_horizon(series: pd.Series, horizon: int) -> pd.Series:
    """Compute forward absolute change over H days: (X[t+H] - X[t]), aligned to t."""
    return series.shift(-horizon) - series


def to_bps(x: pd.Series) -> pd.Series:
    """Convert percentage points to basis points (or ^TNX adjustment)."""
    return x * 100.0


def project_to_simplex(v: np.ndarray) -> np.ndarray:
    """
    Project vector v onto the probability simplex: w >= 0, sum(w) = 1.
    Reference: Duchi et al. (2008)
    """
    if np.sum(v) == 1 and np.all(v >= 0):
        return v
    n = len(v)
    u = np.sort(v)[::-1]
    cssv = np.cumsum(u)
    rho = np.nonzero(u * np.arange(1, n+1) > (cssv - 1))[0][-1]
    theta = (cssv[rho] - 1) / (rho + 1.0)
    w = np.maximum(v - theta, 0)
    return w


def annualize_ret(r: float, horizon_days: int, trading_days: int = 252) -> float:
    """Rough annualization of an H-day return."""
    return (1 + r) ** (trading_days / horizon_days) - 1


# ----------------------------- Data Layer ------------------------------------

def fetch_prices(tickers: Dict[str, str], start: str, end: Optional[str]) -> pd.DataFrame:
    """Fetch adjusted close prices into a single DataFrame with columns=names."""
    data = {}
    for name, t in tickers.items():
        df = yf.download(t, start=start, end=end, progress=False, auto_adjust=True)
        if df.empty:
            raise ValueError(f"No data for {name} ({t}). Try a different ticker or date range.")
        data[name] = df["Close"].rename(name)
    out = pd.DataFrame(data).dropna(how="all")
    return out


def prepare_factor_frame(factors: pd.DataFrame) -> pd.DataFrame:
    """Clean factor frame; convert ^TNX to percentage points."""
    fac = factors.copy()
    if "TNX" in fac.columns:
        # ^TNX is in tenths of a percent (e.g., 43.21 means 4.321%)
        fac["TNX"] = fac["TNX"] / 10.0
    return fac


# ----------------------------- Scenario Model --------------------------------

@dataclass
class Scenario:
    dxy_shock: float   # expected % change over H days, e.g., -0.05 = -5%
    tnx_shock_bps: float  # expected change in bps over H days, e.g., -50
    vix_shock: float   # expected absolute change over H days, e.g., +10

    def as_vector(self) -> np.ndarray:
        # Map to comparable scales (we'll standardize later too)
        # DXY: percent change; TNX: bps; VIX: absolute change
        return np.array([self.dxy_shock, self.tnx_shock_bps, self.vix_shock], dtype=float)

    @staticmethod
    def from_args(args: argparse.Namespace) -> "Scenario":
        return Scenario(
            dxy_shock=args.dxy_shock,
            tnx_shock_bps=args.tnx_shock,
            vix_shock=args.vix_shock,
        )


class AnalogPredictor:
    """
    Finds historical analogs of a scenario using factor deltas over a horizon H.
    Also trains a simple Ridge regression mapping factor deltas -> asset forward returns.
    """
    def __init__(self, horizon: int, lookback: int, kneighbors: int, ridge_l2: float, seed: int = 42):
        self.horizon = horizon
        self.lookback = lookback
        self.kneighbors = kneighbors
        self.ridge_l2 = ridge_l2
        self.seed = seed
        self._fitted = False

    def _build_design(self, factor_df: pd.DataFrame, asset_df: pd.DataFrame) -> Tuple[pd.DataFrame, pd.DataFrame]:
        """
        Build X (factor deltas over horizon) and Y (asset forward returns over horizon)
        aligned to the same index (dates at time t).
        """
        # Factor transforms over horizon
        dxy = factor_df["DXY"]
        tnx = factor_df["TNX"]
        vix = factor_df["VIX"]

        X = pd.DataFrame(index=factor_df.index)
        X["DXY_dh"] = pct_change_over_horizon(dxy, self.horizon)  # % change
        # TNX in bps
        X["TNX_dh_bps"] = to_bps(level_change_over_horizon(tnx, self.horizon))  # absolute change -> bps
        X["VIX_dh"] = level_change_over_horizon(vix, self.horizon)  # absolute change

        # Asset forward returns over horizon
        Y = pd.DataFrame(index=asset_df.index)
        for col in asset_df.columns:
            Y[f"{col}_fwd{self.horizon}d"] = pct_change_over_horizon(asset_df[col], self.horizon)

        # Align and drop rows with NaNs introduced by shifting
        XY = X.join(Y, how="inner").dropna()
        X_clean = XY[X.columns]
        Y_clean = XY[Y.columns]
        return X_clean, Y_clean

    def fit(self, factor_df: pd.DataFrame, asset_df: pd.DataFrame):
        """
        Prepare design matrices and fit scaler + ridge model.
        """
        from sklearn.preprocessing import StandardScaler
        from sklearn.linear_model import Ridge

        self.X, self.Y = self._build_design(factor_df, asset_df)

        self.scaler = StandardScaler()
        self.Xs = pd.DataFrame(
            self.scaler.fit_transform(self.X.values),
            index=self.X.index,
            columns=self.X.columns,
        )

        # Multi-target Ridge (fit per asset)
        self.models: Dict[str, Ridge] = {}
        for ycol in self.Y.columns:
            ridge = Ridge(alpha=self.ridge_l2, random_state=self.seed)
            ridge.fit(self.Xs.values, self.Y[ycol].values)
            self.models[ycol] = ridge

        self._fitted = True

    def find_analogs(self, scenario: Scenario) -> pd.DataFrame:
        """Return kneighbors analog dates with distances in standardized space."""
        assert self._fitted, "Call fit() first."
        s = scenario.as_vector().reshape(1, -1)
        s_std = self.scaler.transform(s)  # same scaling as factors
        # pairwise distance to each historical X (standardized)
        diffs = self.Xs.values - s_std
        dists = np.sqrt((diffs ** 2).sum(axis=1))
        order = np.argsort(dists)[: self.kneighbors]

        df = pd.DataFrame({
            "date": self.Xs.index[order],
            "distance": dists[order],
        }).set_index("date").sort_values("distance")
        return df

    def analog_forward_returns(self, analogs: pd.DataFrame) -> pd.DataFrame:
        """Forward returns for top-k analog dates (rows=dates, cols=assets)."""
        cols = list(self.Y.columns)
        out = self.Y.loc[analogs.index, cols].copy()
        # Rename columns from "Asset_fwdXd" -> "Asset"
        out.columns = [c.replace(f"_fwd{self.horizon}d", "") for c in out.columns]
        return out

    def model_prediction(self, scenario: Scenario) -> pd.Series:
        """Predict forward returns per asset from Ridge model."""
        assert self._fitted, "Call fit() first."
        s = scenario.as_vector().reshape(1, -1)
        s_std = self.scaler.transform(s)
        preds = {}
        for ycol, model in self.models.items():
            preds[ycol.replace(f"_fwd{self.horizon}d", "")] = float(model.predict(s_std)[0])
        return pd.Series(preds).sort_index()


# ----------------------------- Portfolio Layer -------------------------------

def mean_variance_weights(mu: np.ndarray, cov: np.ndarray, risk_aversion: float) -> np.ndarray:
    """
    Solve long-only mean-variance weights with L2 ridge and simplex projection.
    Objective ~ maximize mu^T w - (risk_aversion/2) * w^T cov w
    Here we approximate solution by:
      w* ≈ inv(cov + λI) @ mu, then project to simplex.
    """
    n = len(mu)
    lam = 1e-3  # ridge to stabilize inversion
    A = cov + lam * np.eye(n)
    try:
        raw = np.linalg.solve(A, mu)
    except np.linalg.LinAlgError:
        raw = np.linalg.pinv(A) @ mu
    # Scale by risk aversion
    raw = raw / max(risk_aversion, 1e-6)
    w = project_to_simplex(raw)
    return w


# ----------------------------- Reporting -------------------------------------

def summarize_distribution(df: pd.DataFrame) -> pd.DataFrame:
    """Return summary stats (mean, median, p10, p90, count)."""
    desc = pd.DataFrame({
        "mean": df.mean(),
        "median": df.median(),
        "p10": df.quantile(0.10),
        "p90": df.quantile(0.90),
        "count": df.count(),
    })
    return desc


def save_report(path: str, scenario: Scenario, analogs: pd.DataFrame,
                analog_rets: pd.DataFrame, model_pred: pd.Series,
                blended: pd.Series, weights: pd.Series):
    """Save a CSV report combining key outputs."""
    with open(path, "w", encoding="utf-8") as f:
        f.write("# Scenario\n")
        f.write(json.dumps(asdict(scenario), ensure_ascii=False) + "\n\n")
        f.write("# Analog Dates (top-k)\n")
        f.write(analogs.to_csv())
        f.write("\n# Analog Forward Return Summary\n")
        f.write(summarize_distribution(analog_rets).to_csv())
        f.write("\n# Model Prediction (forward returns)\n")
        f.write(model_pred.to_csv(header=False))
        f.write("\n# Blended Prediction (alpha * model + (1-alpha) * analog mean)\n")
        f.write(blended.to_csv(header=False))
        f.write("\n# Suggested Weights (sum=1)\n")
        f.write(weights.to_csv(header=False))


def maybe_plot(analog_rets: pd.DataFrame, blended: pd.Series, outdir: str):
    if not HAS_MPL:
        return
    import os
    os.makedirs(outdir, exist_ok=True)

    # Boxplot of analog forward returns
    plt.figure()
    analog_rets.boxplot()
    plt.title("Analog Forward Returns Distribution")
    plt.ylabel("Return over Horizon")
    plt.savefig(os.path.join(outdir, "analog_forward_returns_boxplot.png"), dpi=160, bbox_inches="tight")
    plt.close()

    # Barplot of blended predictions
    plt.figure()
    blended.sort_values().plot(kind="barh")
    plt.title("Blended Predicted Forward Returns")
    plt.xlabel("Return over Horizon")
    plt.savefig(os.path.join(outdir, "blended_predictions_bar.png"), dpi=160, bbox_inches="tight")
    plt.close()


# ----------------------------- Main CLI --------------------------------------

def main():
    parser = argparse.ArgumentParser(description="Scenario & Analog Trading App")
    parser.add_argument("--start", type=str, default=DEFAULTS["start"], help="Start date YYYY-MM-DD")
    parser.add_argument("--end", type=str, default=DEFAULTS["end"], help="End date YYYY-MM-DD")
    parser.add_argument("--horizon", type=int, default=DEFAULTS["horizon"], help="Forward horizon in trading days")
    parser.add_argument("--lookback", type=int, default=DEFAULTS["lookback"], help="Not used directly (reserved)")
    parser.add_argument("--kneighbors", type=int, default=DEFAULTS["kneighbors"], help="Number of analogs")
    parser.add_argument("--alpha", type=float, default=DEFAULTS["alpha"], help="Blend weight for model vs analog mean")
    parser.add_argument("--ridge_l2", type=float, default=DEFAULTS["ridge_l2"], help="Ridge L2 strength")
    parser.add_argument("--risk_aversion", type=float, default=DEFAULTS["risk_aversion"], help="Risk-aversion for MV")
    parser.add_argument("--seed", type=int, default=DEFAULTS["seed"], help="Random seed")

    # Scenario shocks
    parser.add_argument("--dxy_shock", type=float, required=True,
                        help="Expected % change in DXY over horizon (e.g., -0.05 = -5%)")
    parser.add_argument("--tnx_shock", type=float, required=True,
                        help="Expected change in 10y yield in basis points over horizon (e.g., -50)")
    parser.add_argument("--vix_shock", type=float, required=True,
                        help="Expected absolute change in VIX over horizon (e.g., +10)")

    parser.add_argument("--plot", action="store_true", help="Save plots to ./output")

    args = parser.parse_args()

    # Fetch data
    assets = fetch_prices(ASSET_TICKERS, args.start, args.end)
    factors_raw = fetch_prices(FACTOR_TICKERS, args.start, args.end)
    factors = prepare_factor_frame(factors_raw)

    # Align calendars
    df = assets.join(factors, how="inner").dropna()
    assets = df[assets.columns]
    factors = df[factors.columns]

    # Initialize and fit predictor
    pred = AnalogPredictor(
        horizon=args.horizon,
        lookback=args.lookback,
        kneighbors=args.kneighbors,
        ridge_l2=args.ridge_l2,
        seed=args.seed,
    )
    pred.fit(factors, assets)

    # Scenario
    scenario = Scenario.from_args(args)

    # Analogs & forward returns
    analogs = pred.find_analogs(scenario)
    analog_rets = pred.analog_forward_returns(analogs)

    # Model prediction
    model_pred = pred.model_prediction(scenario)

    # Blend with analog mean
    analog_mean = analog_rets.mean().reindex(model_pred.index)
    blended = args.alpha * model_pred + (1 - args.alpha) * analog_mean

    # Covariance from analog windows
    cov = analog_rets.cov().loc[blended.index, blended.index].values
    mu = blended.values
    w = mean_variance_weights(mu, cov, risk_aversion=args.risk_aversion)
    weights = pd.Series(w, index=blended.index, name="weight")

    # Print summary
    print("\n=== Scenario (H = {} days) ===".format(args.horizon))
    print(f"DXY % change: {scenario.dxy_shock:+.2%}")
    print(f"TNX change (bps): {scenario.tnx_shock_bps:+.1f}")
    print(f"VIX change (pts): {scenario.vix_shock:+.2f}")

    print("\n=== Top Analogs (k = {}) ===".format(args.kneighbors))
    print(analogs.head(15))

    print("\n=== Analog Forward Return Summary ===")
    print(summarize_distribution(analog_rets))

    print("\n=== Model Prediction (forward returns over horizon) ===")
    print(model_pred.sort_values(ascending=False))

    print("\n=== Blended Prediction (alpha = {:.2f}) ===".format(args.alpha))
    print(blended.sort_values(ascending=False))

    print("\n=== Suggested Portfolio Weights (long-only, sum=1) ===")
    print(weights.sort_values(ascending=False))

    # Save report & plots
    save_report("scenario_report.csv", scenario, analogs, analog_rets, model_pred, blended, weights)
    if args.plot:
        maybe_plot(analog_rets, blended, outdir="output")

    print("\nReport saved to scenario_report.csv")
    if args.plot and HAS_MPL:
        print("Plots saved to ./output")
    elif args.plot and not HAS_MPL:
        print("matplotlib not installed; skipping plots. Install with `pip install matplotlib`.")


if __name__ == "__main__":
    main()
